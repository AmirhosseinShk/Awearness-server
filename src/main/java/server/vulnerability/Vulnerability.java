package server.vulnerability;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class Vulnerability {

    /**
     * The pattern of a CVE id
     */
    public final static Pattern PATTERN = Pattern.compile("^[a-zA-Z]{1,5}-\\d{4}-\\d+$");

    /**
     * The id of the vulnerability in the database
     */
    public int id = 0;

    /**
     * The CVE of the vulnerability on the following format : "CVE-2000-0000"
     */
    public String cve = new String();

    /**
     * The description of the vulnerability
     */
    public String description = new String();

    /**
     * Exploit type (remote exploit, ...)
     */
    public String exploitType = "";

    /**
     * Exploit goal (privilege escalation, ...)
     */
    public String exploitGoal = "";

    /**
     * The cvss related to this vulnerability
     */
    public CVSS cvss = new CVSS();

    /**
     * Default constructor
     *
     * @param id The id of the vulnerability in the database
     * @param cve The CVE of the vulnerability on the following format :
     * "CVE-2000-0000"
     * @param description The description of the vulnerability
     */
    public Vulnerability(int id, String cve, String description) {
        super();
        this.id = id;
        this.cve = cve;
        this.description = description;
    }

    /**
     * Create a vulnerability from the database
     *
     * @param id_vulnerability the id of the vulnerability
     * @param conn the database connection
     * @throws Exception
     */
    public Vulnerability(Connection conn, int id_vulnerability) throws Exception {
        loadFromDatabase(id_vulnerability, conn);
    }

    /**
     * @param cve the CVE
     * @throws Exception
     */
    public Vulnerability(String cve) throws Exception {
        Matcher matcherCVE = Vulnerability.PATTERN.matcher(cve);
        if (!matcherCVE.matches()) {
            this.description = cve;
            this.cve = "";
        } else {
            this.cve = cve;
        }
    }

    /**
     * Get all vulnerabilities of the database
     *
     * @param conn the database connection
     * @return The list of all vulnerabilities
     * @throws Exception
     */
    public static List<Vulnerability> getAllVulnerabilities(Connection conn) throws Exception {
        List<Vulnerability> result = new ArrayList<Vulnerability>();
        PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability");
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        while (res.next()) { //Get all the vulnerabilities
            Vulnerability vulnerability = new Vulnerability(res.getInt(1), res.getString(2), res.getString(3));
            result.add(vulnerability);
        }
        return result;
    }

    /**
     * Get the id of the vulnerability related to a CVE
     *
     * @param cve the cve string
     * @param conn the database connection
     * @return the id of the vulnerability
     * @throws Exception
     */
    public static int getIdVulnerabilityFromCVE(String cve, Connection conn) throws Exception {
        PreparedStatement pstmt = conn.prepareStatement("SELECT id FROM vulnerability WHERE cve LIKE ?");
        pstmt.setString(1, cve);
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        boolean found = res.next();
        int result = 0;
        if (found) {
            result = res.getInt(1);
        }
        res.close();
        return result;
    }


    /**
     * Find whether or not the vulnerability is in the database and update the
     * object in database
     *
     * @param conn the database connection
     * @return true if the vulnerability is in the database, else false
     * @throws java.sql.SQLException
     */
    public boolean inDatabase(Connection conn) throws SQLException {
        PreparedStatement pstmt = conn.prepareStatement("SELECT id,cve,description,cvss_id FROM vulnerability WHERE cve LIKE ?");
        pstmt.setString(1, cve);
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        boolean result = res.next();
        if (result) { //This CVE is already in the DB
            //We get the id of this vulnerability and update the description
            id = res.getInt(1);
            if ((!description.isEmpty() && !description.equals(res.getString(3))) || cvss.getId() != res.getInt(4)) {
                res.close();
                PreparedStatement pstmt2 = conn.prepareStatement("UPDATE vulnerability SET description = ?, cvss_id = ? WHERE id = ?");
                pstmt2.setString(1, description);
                pstmt2.setInt(2, cvss.getId());
                pstmt2.setInt(3, id);
                pstmt2.execute();
                pstmt2.close();
            }
        }
        pstmt.close();
        res.close();
        return result;
    }

    /**
     * Add the vulnerability to the database
     *
     * @param conn the database connection
     * @throws java.sql.SQLException
     */
    public void addToDatabase(Connection conn) throws SQLException {
        if (!this.inDatabase(conn)) { //This vulnerability is not yet in the DB, so we had it
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO vulnerability(cve,description,cvss_id) VALUES(?,?,?)");
            pstmt.setString(1, cve);
            pstmt.setString(2, description);
            pstmt.setInt(3, cvss.getId());
            pstmt.execute();
            ResultSet resultSetId = pstmt.getGeneratedKeys();
            id = resultSetId.getInt(1);
            resultSetId.close();
        }
    }

    /**
     * Add a CPE to a vulnerability in the database
     *
     * @param cpe the cpe to add to the vulnerability
     * @param conn the connection to the database
     * @throws Exception
     */
    public void addACPEInDatabase(CPE cpe, Connection conn) throws Exception {
        addToDatabase(conn); //We add the vulnerability in the database
        cpe.saveToDatabase(conn); //We add the cpe in the database

        PreparedStatement pstmt = conn.prepareStatement("REPLACE INTO cpe_vulnerability(id_cpe,id_vulnerability) VALUES(?,?)");
        pstmt.setInt(1, cpe.id);
        pstmt.setInt(2, this.id);
        pstmt.execute();
        pstmt.close();

    }

    /**
     * Add a CPE to a vulnerability in the database
     *
     * @param cwe the cpe to add to the vulnerability
     * @param conn the connection to the database
     * @throws Exception
     */
    public void addACWEInDatabase(CWE cwe, Connection conn) throws Exception {
        addToDatabase(conn); //We add the vulnerability in the database
        cwe.saveToDatabase(conn); //We add the cwe in the database

        PreparedStatement pstmt = conn.prepareStatement("REPLACE INTO cpe_vulnerability(id_cpe,id_vulnerability) VALUES(?,?)");
        pstmt.setInt(1, cwe.id);
        pstmt.setInt(2, this.id);
        pstmt.execute();
        pstmt.close();

    }

    /**
     * Load a vulnerability from the database with an id
     *
     * @param conn The Database connection
     * @param id_vulnerability The id of the vulnerability
     * @return true if the vulnerability was in the database, else false
     * @throws java.sql.SQLException
     */
    public boolean loadFromDatabase(int id_vulnerability, Connection conn) throws SQLException {
        if (id_vulnerability <= 0) {
            return false;
        }
        PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability WHERE id = ?");
        pstmt.setInt(1, id_vulnerability);
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        if (res.next()) {
            id = res.getInt(1);
            cve = res.getString(2);
            description = res.getString(3);
            int id_cvss = res.getInt(4);
            if (id_cvss > 0) {
                cvss.loadFromDatabase(id_cvss, conn);
            }
            res.close();
            return true;

        } else {
            return false;
        }
    }

    /**
     * Load all the parameters : id, cvss... (except the CVE) from the database
     * with the cve identifier
     *
     * @throws java.sql.SQLException
     */
    public void loadParametersFromDatabase(Connection conn) throws SQLException {
        if (cve.isEmpty() || cve.equals("")) {
            return;
        }
        PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability WHERE cve LIKE ?");
        pstmt.setString(1, cve);
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        if (res.next()) {
            id = res.getInt(1);
            description = res.getString(3);
            int id_cvss = res.getInt(4);
            if (id_cvss > 0) {
                cvss.loadFromDatabase(id_cvss, conn);
            }
            res.close();

        }
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((cve == null) ? 0 : cve.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Vulnerability other = (Vulnerability) obj;
        if (cve == null) {
            if (other.cve != null) {
                return false;
            }
        } else if (!cve.equals(other.cve)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "Vulnerability [cve=" + cve + ", description=" + description
                + ", exploitType=" + exploitType + ", exploitGoal=" + exploitGoal
                + "]";
    }

}
